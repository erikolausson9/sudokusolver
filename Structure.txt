Sudoku solver

- Handle imput image
    - Turn color jpeg into grayscale
    - Turn image into integer 2D-array
    - Extract features using convolution and sobel filter

- Find corners
    - In memory, store feature extracted 2D-arrays of the four corners with different scale (9x9 and 16x16 perhaps?)
    - "Walk" over the input feature 2D-array and find the best match for each.
    - Use some logic to make it more robust: use best match of same scale (for all four corners) and make sure the best matches are correctly placed compared to each other geographically.
    - Optional: use threshold to abort if we can't get good enough matches of the four corners.

- Image normalization
    - If the number matrix is very skewed in the photo - can we use some kind of transform to straighten it up? Or perphas this is not necessary/befinical?
    - Scale the 2D-matrix to some appropriate value so the comparisons with numbers will be correct in the next step. 

- Find numbers
    - Cut out the 81 squares where we expect the numbers to be (or blank spaces) based on the positions of the four outer corners.
    - For each square:
        - First determine if the square is empty or not using an apporpriate threshold
        - If not empty, compare to feature extracted 2D-arryas of numbers 1-9 and find the best match.
    - The output of this step should be a 9x9 2D-matrix of lists, where each lists contains the possible numbers for that positions. Thus, given numbers have only one element in the list while the empty squares have nine.

- Solve Sudoku
    - Repeat until solved, that is until all squares have a list lenght of one.
        - For each square:
            - If lenght of list is one, skip since this square is already given or solved.
            - Check the horizontal line and remove all given/solved numbers present from the list.
            - Check the vertical line and remove all given/solved numbers present from the list.
            - Check the 3x3 square and remove all given/solved numbers present from the list.  
    - If this gets stuck in an infinite loop, we need to add more complicated logic to solve the Sudoku. To be determined.


Läget
3 december:
Har börjat med funktionen sobel_convolution, gjord för att falta med sobel filter
5 december:
verkar vara något krux med uint8 i sobel faltningen. Dessutom: faltningen tar ett par sekunder även på en bild som bara är 600 x 618 pixlar...
16 december:
Faltningen funkar, likaså att hitta lower left corner. Men att hitta ett enda hörn tar några minuter, behöver snabbas upp. Kolla bara 1/4 av bilden och använd info från tidigare hittade hörn för att leta på rätt ställe för de återstående...
Parallellt försöker jag göra en "heatmap" kallad diff_array men talen blir för stora för att det ska gå att se något annat än vitt i bilden. Behöver normaliseras, hur gör man det med en numpy array? Använd best_score som högsta värde och 0 som lägsta!
20 december:
Nu finns det lagrade, som numpy-arrayer, faltade bilder av top left och top right corner från sudoku_far_away nedskalad till 300x400. Hörnen är bara 10x10 pixlar, med det kanske räcker? Den hittar i alla fall när jag försöker hitta hörnen igen på samma bild. Men på Sudoku2 hittar den bara top left corner än så länge. Problemet är nog att själva sodkuot är dubbelt så stort på sudoku2.jpg som på sudoku_far_away.jpg och då blir även hörnen olika skala.

26 december:
Det börjar likna något. Testar att hitta hörnen på olika bilder med varierande framgång. Senaste försöket är med 16x16-hörn från sudoku2. Behöver differientiera mall-hörnen (för att kunna testa med olika på samma bild) och börja köra lite mer 
storskalig testning för att se vilka parametrar som ger bäst resultat. Jag behöver också testa med en ny bild med mitt-emellan-inzoomning av själva sudokut, istället för det två olika extremlägen jag testar med nu (sudoku2.jpg och sudoku_far_away.jpg)

2 januari:
Hörnen funkar nu rimligt bra på de bilder jag testat utom far_way, där vi hittar tre av fyra hörn. Jobbar med evaluate_corners. Oklart hur stor margin of error vi ska acceptera för hörnen, på sudoku_extrabild är pappret lite vikt vilket gör skillnaderna mellan hörnen rätt stor även om det algoritmen hittar rätt position.
2 januari, kväll:
Nu ger den en approximation av det fjärde hörnet om bara tre är rätt. Oklart om detta hjälper oss eller inte, det återstår att se när vi testar att identifiera siffrorna i cellerna...
6 januari:
Segmenteringen fungerar så bra som den kan utan att göra någon 4 point transform. Saknas ett hörn blir det nog lite konstigt, men kanske går det ändå, vi får se.
Nästa steg blir att i varje segmenterad bild (som har mer än ett visst medeltal i pixelvärde och därmed inte räknas som tom) köra en threshold och sedan jämföra med de nio olika siffrorna det kan vara. Dessa borde även flytta runt lite i rutan för att göra träffsäkerheten bättre. 